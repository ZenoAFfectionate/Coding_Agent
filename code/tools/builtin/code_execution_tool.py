"""CodeExecutionTool - Sandboxed Code Execution

Provides safe code execution for a Coding Agent:
- Execute Python code in an isolated subprocess
- Execute shell/bash commands
- Capture stdout, stderr, and exit code
- Timeout and output-size limits
- Temporary file management

Safety:
- Code runs in a subprocess, NOT in the agent's process
- Configurable timeout (default 30s)
- Output size limits
- Optional restricted mode (no network, no file writes outside workspace)
"""

import os
import re as _re
import subprocess
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional

from ...utils.subprocess_utils import safe_run
from ..base import Tool, ToolParameter, tool_action


class CodeExecutionTool(Tool):
    """Sandboxed code execution tool.

    Executes Python or shell code in an isolated subprocess and returns
    structured results with stdout, stderr, and exit code.

    Note: Shell execution uses subprocess with shell=True. While the agent
    operates in a sandboxed workspace, exercise caution with the commands
    generated by the LLM. A basic blocklist prevents the most dangerous
    patterns, but this is not a security boundary.
    """

    # Basic blocklist for obviously destructive shell commands
    DANGEROUS_SHELL_PATTERNS = [
        "rm -rf /", "rm -rf ~", "rm -rf /*",
        "mkfs.", ":(){:|:&};:",
        "> /dev/sd", "dd if=/dev/zero",
        "chmod -R 777 /",
    ]

    def __init__(
        self,
        workspace: str = ".",
        timeout: int = 30,
        max_output_size: int = 1024 * 1024,  # 1 MB
        python_executable: str = "python3",
        expandable: bool = False,
    ):
        super().__init__(
            name="code_exec",
            description=(
                "Execute Python or shell code in a sandboxed subprocess. "
                "Returns stdout, stderr, and exit code."
            ),
            expandable=expandable,
        )
        self.workspace = Path(workspace).resolve()
        self.timeout = timeout
        self.max_output_size = max_output_size
        self.python_executable = python_executable
        self.workspace.mkdir(parents=True, exist_ok=True)

    def run(self, parameters: Dict[str, Any]) -> str:
        action = parameters.get("action", "python")
        dispatch = {
            "python": self._run_python,
            "shell": self._run_shell,
        }
        handler = dispatch.get(action)
        if handler is None:
            return f"Unsupported action '{action}'. Supported: {', '.join(dispatch)}"
        return handler(parameters)

    def get_parameters(self) -> List[ToolParameter]:
        return [
            ToolParameter(name="action", type="string",
                          description="Execution mode", required=True,
                          enum=["python", "shell"]),
            ToolParameter(name="code", type="string",
                          description="Code/command to execute", required=True),
            ToolParameter(name="timeout", type="integer",
                          description=f"Timeout in seconds (default {self.timeout})",
                          required=False, default=self.timeout),
        ]

    def _truncate(self, text: str) -> str:
        if len(text) > self.max_output_size:
            return text[: self.max_output_size] + f"\n... truncated ({len(text)} bytes total)"
        return text

    @staticmethod
    def _compact_traceback(stderr: str, max_frames: int = 5) -> str:
        """Extract only the last *max_frames* frames from a Python traceback.

        Non-traceback stderr is returned untouched. If a traceback block is
        detected, keep only the last *max_frames* ``File "..."`` entries plus
        the final error line.
        """
        tb_header = "Traceback (most recent call last):\n"
        idx = stderr.find(tb_header)
        if idx == -1:
            return stderr

        before = stderr[:idx]
        tb_block = stderr[idx + len(tb_header):]

        # Split into frames: each frame starts with "  File "
        frame_lines: List[str] = []
        current_frame: List[str] = []
        error_line = ""

        for line in tb_block.splitlines(keepends=True):
            if line.startswith("  File "):
                if current_frame:
                    frame_lines.append("".join(current_frame))
                current_frame = [line]
            elif line.startswith("    ") and current_frame:
                current_frame.append(line)
            else:
                # This is the error line (or extra text after the traceback)
                if current_frame:
                    frame_lines.append("".join(current_frame))
                    current_frame = []
                error_line += line

        if current_frame:
            frame_lines.append("".join(current_frame))

        total_frames = len(frame_lines)
        if total_frames <= max_frames:
            # Nothing to truncate
            return stderr

        hidden = total_frames - max_frames
        kept_frames = frame_lines[-max_frames:]
        compact = before + tb_header
        compact += f"  ... ({hidden} earlier frames hidden)\n"
        compact += "".join(kept_frames)
        compact += error_line
        return compact

    @tool_action("exec_python", "Execute Python code in an isolated subprocess")
    def _run_python(self, parameters: Dict[str, Any]) -> str:
        """Execute Python code.

        Args:
            parameters: Dict with code and optional timeout.
        Returns:
            Structured execution result.
        """
        code = parameters.get("code", "")
        if not code.strip():
            return "Error: code is empty."

        # Fast-fail: detect stdin-blocking patterns to avoid 30s timeout
        _stdin_patterns = [
            r'\bsys\.stdin\.read\b',
            r'\bsys\.stdin\.readline\b',
            r'\binput\s*\(',
        ]
        # Only check top-level code (not inside function defs that won't be called)
        for pattern in _stdin_patterns:
            if _re.search(pattern, code):
                # Check if the call is at module level (not just inside a def)
                for line in code.splitlines():
                    stripped = line.lstrip()
                    if _re.search(pattern, stripped) and not stripped.startswith(('#', 'def ', 'class ')):
                        indent = len(line) - len(stripped)
                        # Top-level or in if __name__ block (indent 0 or 4)
                        if indent <= 4:
                            return (
                                "Error: code_exec(\"python\", ...) has no stdin attached â€” "
                                "sys.stdin.read() / input() will hang until timeout.\n"
                                "Fix: write the solution to a file first, then use "
                                "code_exec(\"shell\", \"echo '...' | python solution.py\") to pipe input."
                            )

        timeout = parameters.get("timeout", self.timeout) or self.timeout

        # Write code to a temp file and execute
        try:
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".py", dir=str(self.workspace),
                delete=False, encoding="utf-8",
            ) as f:
                f.write(code)
                tmp_path = f.name

            result = safe_run(
                [self.python_executable, tmp_path],
                cwd=str(self.workspace),
                capture_output=True,
                text=True,
                timeout=timeout,
                env={**os.environ, "PYTHONDONTWRITEBYTECODE": "1"},
            )

            stdout = self._truncate(result.stdout)
            stderr = self._truncate(self._compact_traceback(result.stderr))

            parts = [f"=== Python Execution Result ==="]
            parts.append(f"Exit code: {result.returncode}")
            if stdout.strip():
                parts.append(f"\n--- stdout ---\n{stdout}")
            if stderr.strip():
                parts.append(f"\n--- stderr ---\n{stderr}")
            if not stdout.strip() and not stderr.strip():
                parts.append("(no output)")

            return "\n".join(parts)

        except subprocess.TimeoutExpired:
            return f"Error: execution timed out after {timeout}s"
        except Exception as e:
            return f"Error executing Python code: {e}"
        finally:
            try:
                os.unlink(tmp_path)
            except (OSError, UnboundLocalError):
                pass

    @tool_action("exec_shell", "Execute a shell command")
    def _run_shell(self, parameters: Dict[str, Any]) -> str:
        """Execute a shell command.

        Args:
            parameters: Dict with code (shell command), timeout.
        Returns:
            Structured execution result.
        """
        command = parameters.get("code", "")
        if not command.strip():
            return "Error: command is empty."

        # Basic safety check for destructive patterns
        cmd_lower = command.lower().strip()
        for pattern in self.DANGEROUS_SHELL_PATTERNS:
            if pattern in cmd_lower:
                return "Blocked: potentially dangerous command pattern detected."

        timeout = parameters.get("timeout", self.timeout) or self.timeout

        try:
            result = safe_run(
                command,
                shell=True,
                cwd=str(self.workspace),
                capture_output=True,
                text=True,
                timeout=timeout,
            )

            stdout = self._truncate(result.stdout)
            stderr = self._truncate(self._compact_traceback(result.stderr))

            parts = [f"=== Shell Execution Result ==="]
            parts.append(f"Command: {command}")
            parts.append(f"Exit code: {result.returncode}")
            if stdout.strip():
                parts.append(f"\n--- stdout ---\n{stdout}")
            if stderr.strip():
                parts.append(f"\n--- stderr ---\n{stderr}")
            if not stdout.strip() and not stderr.strip():
                parts.append("(no output)")

            return "\n".join(parts)

        except subprocess.TimeoutExpired:
            return f"Error: command timed out after {timeout}s"
        except Exception as e:
            return f"Error executing shell command: {e}"
